/**
 * Bundled by jsDelivr using Rollup v2.79.2 and Terser v5.39.0.
 * Original file: /npm/@levischuck/tiny-encodings@0.2.11/esm/index.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
function t(t){if(t instanceof DataView)return t;if(t instanceof Uint8Array||t instanceof Int8Array||t instanceof Int16Array||t instanceof Uint16Array||t instanceof Int32Array||t instanceof Uint32Array||t instanceof Uint8ClampedArray||t instanceof Float32Array||t instanceof Float64Array||t instanceof BigInt64Array||t instanceof BigUint64Array)return new DataView(t.buffer);if(t instanceof ArrayBuffer)return new DataView(t);throw new Error("Unsupported type")}const n=new TextDecoder,e=new TextEncoder,r=e.encode("0123456789ABCDEF"),i=new Uint8Array(256);function o(t){if(0==t.byteLength)return"";const e=t.byteLength,i=new Uint8Array(2*t.byteLength);for(let n=0,o=0;n<e;n++,o+=2){const e=t.getUint8(n);i[o]=r[(240&e)>>4],i[o+1]=r[15&e]}return n.decode(i)}function a(t){if(t instanceof Uint8Array||t instanceof Int8Array||t instanceof Int16Array||t instanceof Uint16Array||t instanceof Int32Array||t instanceof Uint32Array||t instanceof Uint8ClampedArray||t instanceof Float32Array||t instanceof Float64Array||t instanceof BigInt64Array||t instanceof BigUint64Array)return o(new DataView(t.buffer));if(t instanceof ArrayBuffer)return o(new DataView(t));if(t instanceof DataView)return o(t);throw new Error("Bad input to encodeHex")}const f="Bad input to decodeHex";function c(t){if(""==t)return new Uint8Array;const n=e.encode(t);let r=0,o=!1;if(1&n.length)throw new Error(f);if(0==i[0])for(let t=0;t<256;t++)i[t]=t>=48&&t<=57?t-48:t>=65&&t<=70?t-55:t>=97&&t<=102?t-87:255;const a=new Uint8Array(Math.ceil(t.length/2));for(let t=0;t<n.length;t+=2,r++){const e=n[t],f=n[t+1],c=i[e],s=i[f];if(a[r]=c<<4|s,255==c||255==s){o=!0;break}}if(o)throw new Error(f);return a}const s="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",y=e.encode(s),u=new Uint8Array(256),w="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",g=e.encode(w),l=new Uint8Array(256);function A(e,r,i){const o=t(e),[a,f,c]=function(t,n){const e=4*Math.ceil(t/3),r=t%3,i=0==r?t:t-r;return n||0==r?[e,i,r]:1==r?[e-2,i,r]:[e-1,i,r]}(o.byteLength,i),s=new Uint8Array(a);let y=0;for(let t=0;t<f;t+=3){const n=o.getUint8(t),e=o.getUint8(t+1),i=o.getUint8(t+2);s[y]=r[(252&n)>>2],s[y+1]=r[(3&n)<<4|(240&e)>>4],s[y+2]=r[(15&e)<<2|(192&i)>>6],s[y+3]=r[63&i],y+=4}if(1==c){const t=o.getUint8(f);s[y]=r[(252&t)>>2],s[y+1]=r[(3&t)<<4],i&&(s[y+2]=61,s[y+3]=61)}else if(2==c){const t=o.getUint8(f),n=o.getUint8(f+1);s[y]=r[(252&t)>>2],s[y+1]=r[(3&t)<<4|(240&n)>>4],s[y+2]=r[(15&n)<<2],i&&(s[y+3]=61)}return n.decode(s)}function h(t){return A(t,y,!0)}function U(t){return A(t,g,!1)}function b(t,e,r,i,o){let a=0,f=null;const c=e-r;for(let n=0;n<c;n+=4,a+=3){const e=o[t[n]],r=o[t[n+1]],c=o[t[n+2]],s=o[t[n+3]];if(i[a]=e<<2|(48&r)>>4,i[a+1]=(15&r)<<4|(60&c)>>2,i[a+2]=(3&c)<<6|s,255==e||255==r||255==c||255==s){f=n;break}}if(null!=f)throw new Error("Unsupported characters in base64: "+n.decode(new Uint8Array([t[f],t[f+1],t[f+2],t[f+3]])));if(2==r){const r=t[e-2],f=t[e-1],c=o[r],s=o[f];if(255==(c|s))throw new Error("Unsupported characters in base64: "+n.decode(new Uint8Array([r,f]))+JSON.stringify([c,s]));if(i[a]=c<<2|(48&s)>>4,15&s)throw new Error("Mangled Base64 padding")}else if(3==r){const r=t[e-3],f=t[e-2],c=t[e-1],s=o[r],y=o[f],u=o[c];if(255==(s|y|u))throw new Error("Unsupported characters in base64: "+n.decode(new Uint8Array([r,f,c]))+JSON.stringify([s,y,u]));if(i[a]=s<<2|(48&y)>>4,i[a+1]=(15&y)<<4|(60&u)>>2,3&u)throw new Error("Mangled Base64 padding")}}function d(t){let n=t.length;for(let e=n-1;e>=0;e--)61==t[e]&&(n=e);const e=n%4;let r;if(2==e)r=(n-2)/4*3+1;else if(3==e)r=(n-3)/4*3+2;else{if(0!=e)throw new Error("Invalid base64 length");r=n/4*3}return[n,e,r]}function I(t){if("string"!=typeof t)throw new Error("Expecting a string");if(0==t.length)return new Uint8Array([]);if(0==u[0]){for(let t=0;t<256;t++)u[t]=255;for(let t=0;t<64;t++)u[s.charCodeAt(t)]=t}const n=e.encode(t),[r,i,o]=d(n),a=new Uint8Array(o);return b(n,r,i,a,u),a}function p(t){if("string"!=typeof t)throw new Error("Expecting a string");if(0==t.length)return new Uint8Array([]);if(0==l[0]){for(let t=0;t<256;t++)l[t]=255;for(let t=0;t<64;t++)l[w.charCodeAt(t)]=t}const n=e.encode(t),[r,i,o]=d(n),a=new Uint8Array(o);return b(n,r,i,a,l),a}const E=new Uint8Array(2);function L(){return 0!=E[1]}function B(){return 0!=E[0]}function F(){return L()?"big":"little"}function m(t,n,e,r){const i=new Uint8Array(t.byteLength),o=new DataView(i.buffer),a=t.length,f="little"==n;for(let n=0,i=0;n<a;n++,i+=e)r(o,i,t[n],f);return i}function D(t,n,e,r,i){for(let o=0,a=0;o<t.byteLength;a++,o+=e)r[a]=i(t,o,n);return r}function q(t,n){return t instanceof Uint8Array?t:t instanceof Uint16Array?m(t,n,2,((t,n,e,r)=>t.setUint16(n,e,r))):t instanceof Int16Array?m(t,n,2,((t,n,e,r)=>t.setInt16(n,e,r))):t instanceof Uint32Array?m(t,n,4,((t,n,e,r)=>t.setUint32(n,e,r))):t instanceof Int32Array?m(t,n,4,((t,n,e,r)=>t.setInt32(n,e,r))):t instanceof BigUint64Array?m(t,n,8,((t,n,e,r)=>t.setBigUint64(n,e,r))):t instanceof BigInt64Array?m(t,n,8,((t,n,e,r)=>t.setBigInt64(n,e,r))):t instanceof Float32Array?m(t,n,4,((t,n,e,r)=>t.setFloat32(n,e,r))):t instanceof Float64Array?m(t,n,8,((t,n,e,r)=>t.setFloat64(n,e,r))):new Uint8Array(t.buffer)}function x(n,e,r){const i=t(n),o="little"==e;if("int8"==r)return D(i,o,1,new Int8Array(i.byteLength),((t,n,e)=>t.getInt8(n)));if("uint16"==r){if(1&i.byteLength)throw new Error("Incomplete byte sequence");return D(i,o,2,new Uint16Array(i.byteLength>>>1),((t,n,e)=>t.getUint16(n,e)))}if("int16"==r){if(1&i.byteLength)throw new Error("Incomplete byte sequence");return D(i,o,2,new Int16Array(i.byteLength>>>1),((t,n,e)=>t.getInt16(n,e)))}if("uint32"==r){if(3&i.byteLength)throw new Error("Incomplete byte sequence");return D(i,o,4,new Uint32Array(i.byteLength>>>2),((t,n,e)=>t.getUint32(n,e)))}if("int32"==r){if(3&i.byteLength)throw new Error("Incomplete byte sequence");return D(i,o,4,new Int32Array(i.byteLength>>>2),((t,n,e)=>t.getInt32(n,e)))}if("uint64"==r){if(7&i.byteLength)throw new Error("Incomplete byte sequence");return D(i,o,8,new BigUint64Array(i.byteLength>>>3),((t,n,e)=>t.getBigUint64(n,e)))}if("int64"==r){if(7&i.byteLength)throw new Error("Incomplete byte sequence");return D(i,o,8,new BigInt64Array(i.byteLength>>>3),((t,n,e)=>t.getBigInt64(n,e)))}if("float32"==r){if(3&i.byteLength)throw new Error("Incomplete byte sequence");return D(i,o,4,new Float32Array(i.byteLength>>>2),((t,n,e)=>t.getFloat32(n,e)))}if("float64"==r){if(7&i.byteLength)throw new Error("Incomplete byte sequence");return D(i,o,8,new Float64Array(i.byteLength>>>3),((t,n,e)=>t.getFloat64(n,e)))}return new Uint8Array(i.buffer.slice(i.byteOffset,i.byteOffset+i.byteLength))}new Uint16Array(E.buffer)[0]=1;export{x as arrayFromEndian,q as arrayToEndian,I as decodeBase64,p as decodeBase64Url,c as decodeHex,h as encodeBase64,U as encodeBase64Url,a as encodeHex,F as hostEndianness,L as hostIsBigEndian,B as hostIsLittleEndian};export default null;
//# sourceMappingURL=./tiny-encodings.0.2.11.esm.min.map
