/**
 * Bundled by jsDelivr using Rollup v2.79.2 and Terser v5.39.0.
 * Original file: /npm/@levischuck/tiny-cbor@0.3.2/esm/index.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
function e(e,t,r){if(t<24)return[t,1];const n=e.byteLength-r-1,o=new DataView(e.buffer,r+1);let i,u=0;switch(t){case 24:n>0&&(i=o.getUint8(0),u=2);break;case 25:n>1&&(i=o.getUint16(0,!1),u=3);break;case 26:n>3&&(i=o.getUint32(0,!1),u=5);break;case 27:if(n>7){const e=o.getBigUint64(0,!1);return e>=24n&&e<=Number.MAX_SAFE_INTEGER?[Number(e),9]:[e,9]}}if(i&&i>=24)return[i,u];throw new Error("Length not supported or not well formed")}function t(e,t){const r=e<<5;if(t<0)throw new Error("CBOR Data Item argument must not be negative");let n;if("number"==typeof t){if(!Number.isInteger(t))throw new Error("CBOR Data Item argument must be an integer");n=BigInt(t)}else n=t;if(1==e){if(0n==n)throw new Error("CBOR Data Item argument cannot be zero when negative");n-=1n}if(n>18446744073709551615n)throw new Error("CBOR number out of range");const o=new Uint8Array(8);return new DataView(o.buffer).setBigUint64(0,n,!1),n<=23?[r|o[7]]:n<=255?[24|r,o[7]]:n<=65535?[25|r,...o.slice(6)]:n<=4294967295?[26|r,...o.slice(4)]:[27|r,...o]}class r{constructor(e,t){Object.defineProperty(this,"tagId",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"tagValue",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.tagId=e,this.tagValue=t}get tag(){return this.tagId}get value(){return this.tagValue}}function n(t,r,n){return e(t,r,n)}function o(t,r,n){const[o,i]=e(t,r,n);if("bigint"==typeof o)throw new Error("ByteString length is too large");const u=n+i;return[new Uint8Array(t.buffer.slice(u,u+o)),i+o]}const i=new TextDecoder;const u="Map is not supported or well formed";function a(t,f){if(f>=t.byteLength)throw new Error("CBOR stream ended before tag value");const s=t.getUint8(f),c=31&s;switch(s>>5){case 0:return n(t,c,f);case 1:return function(e,t,r){const[o,i]=n(e,t,r);return"bigint"==typeof o?[-o-1n,i]:[-o-1,i]}(t,c,f);case 2:return o(t,c,f);case 3:return function(e,t,r){const[n,u]=o(e,t,r);return[i.decode(n),u]}(t,c,f);case 4:return function(t,r,n){if(0===r)return[[],1];const[o,i]=e(t,r,n);let u=i;const f=[];for(let e=0;e<o;e++){if(t.byteLength-n-u<=0)throw new Error("array is not supported or well formed");const[e,r]=a(t,n+u);f.push(e),u+=r}return[f,u]}(t,c,f);case 5:return function(t,r,n){if(0===r)return[new Map,1];const[o,i]=e(t,r,n);let f=i;const s=new Map;for(let e=0;e<o;e++){let e=t.byteLength-n-f;if(e<=0)throw new Error(u);const[r,o]=a(t,n+f);if(f+=o,e-=o,e<=0)throw new Error(u);if("string"!=typeof r&&"number"!=typeof r)throw new Error(u);if(s.has(r))throw new Error(u);const[i,c]=a(t,n+f);f+=c,s.set(r,i)}return[s,f]}(t,c,f);case 6:return function(t,n,o){const[i,u]=e(t,n,o),[f,s]=a(t,o+u);return[new r(i,f),u+s]}(t,c,f);case 7:switch(c){case 20:return[!1,1];case 21:return[!0,1];case 22:return[null,1];case 23:return[void 0,1];case 25:return function(e,t){if(t+3>e.byteLength)throw new Error("CBOR stream ended before end of Float 16");const r=e.getUint16(t+1,!1);if(31744==r)return[1/0,3];if(32256==r)return[NaN,3];if(64512==r)return[-1/0,3];throw new Error("Float16 data is unsupported")}(t,f);case 26:return function(e,t){if(t+5>e.byteLength)throw new Error("CBOR stream ended before end of Float 32");return[e.getFloat32(t+1,!1),5]}(t,f);case 27:return function(e,t){if(t+9>e.byteLength)throw new Error("CBOR stream ended before end of Float 64");return[e.getFloat64(t+1,!1),9]}(t,f)}}throw new Error(`Unsupported or not well formed at ${f}`)}function f(e){if(Math.fround(e)==e||!Number.isFinite(e)||Number.isNaN(e)){const t=new Uint8Array(5);t[0]=250;return new DataView(t.buffer).setFloat32(1,e,!1),t}{const t=new Uint8Array(9);t[0]=251;return new DataView(t.buffer).setFloat64(1,e,!1),t}}const s=new TextEncoder;function c(e,n){if("boolean"!=typeof e&&null!==e&&null!=e)if("number"!=typeof e&&"bigint"!=typeof e)if("string"!=typeof e)if(e instanceof Uint8Array)!function(e,r){r.push(...t(2,e.length)),r.push(e)}(e,n);else if(Array.isArray(e))!function(e,r){r.push(...t(4,e.length));for(const t of e)c(t,r)}(e,n);else if(e instanceof Map)!function(e,r){r.push(new Uint8Array(t(5,e.size)));for(const[t,n]of e.entries())c(t,r),c(n,r)}(e,n);else{if(!(e instanceof r))throw new Error("Not implemented");!function(e,r){r.push(...t(6,e.tag)),c(e.value,r)}(e,n)}else!function(e,r){r.push(...t(3,e.length)),r.push(s.encode(e))}(e,n);else n.push(...function(e){return"number"==typeof e?Number.isSafeInteger(e)?e<0?t(1,Math.abs(e)):t(0,e):[f(e)]:e<0n?t(1,-1n*e):t(0,e)}(e));else n.push(function(e){return!0===e?245:!1===e?244:null===e?246:247}(e))}function w(e,t){if(0===e.byteLength||e.byteLength<=t||t<0)throw new Error("No data");const r=Object.getPrototypeOf(e),n=r===ArrayBuffer.prototype,o="undefined"!=typeof SharedArrayBuffer&&r===SharedArrayBuffer.prototype;if(r.constructor===Uint8Array.prototype.constructor)return a(new DataView(e.buffer),t);if(n||o)return a(new DataView(e),t);if(r===DataView.prototype)return a(e,t);throw new Error("Unsupported data type")}function l(e){const[t,r]=w(e,0);if(r!==e.byteLength)throw new Error(`Data was decoded, but the whole stream was not processed ${r} != ${e.byteLength}`);return t}function h(e){const t=[];c(e,t);let r=0;for(const e of t)r+="number"==typeof e?1:e.length;const n=new Uint8Array(r);let o=0;for(const e of t)"number"==typeof e?(n[o]=e,o+=1):(n.set(e,o),o+=e.length);return n}export{r as CBORTag,l as decodeCBOR,w as decodePartialCBOR,h as encodeCBOR};export default null;
//# sourceMappingURL=./tiny-cbor.0.3.2.esm.min.map
