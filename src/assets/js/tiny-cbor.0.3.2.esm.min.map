{"version":3,"sources":["jsdelivr-header.js","/npm/@levischuck/tiny-cbor@0.3.2/esm/cbor/cbor_internal.js","/npm/@levischuck/tiny-cbor@0.3.2/esm/cbor/cbor.js"],"names":[],"mappings":"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","file":"/npm/@levischuck/tiny-cbor@0.3.2/esm/index.js/+esm","sourceRoot":"","sourcesContent":["/**\n * Bundled by jsDelivr using Rollup v2.79.2 and Terser v5.39.0.\n * Original file: /npm/@levischuck/tiny-cbor@0.3.2/esm/index.js\n *\n * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files\n */\n","export function decodeLength(data, argument, index) {\n    if (argument < 24) {\n        return [argument, 1];\n    }\n    const remainingDataLength = data.byteLength - index - 1;\n    const view = new DataView(data.buffer, index + 1);\n    let output;\n    let bytes = 0;\n    switch (argument) {\n        case 24: {\n            if (remainingDataLength > 0) {\n                output = view.getUint8(0);\n                bytes = 2;\n            }\n            break;\n        }\n        case 25: {\n            if (remainingDataLength > 1) {\n                output = view.getUint16(0, false);\n                bytes = 3;\n            }\n            break;\n        }\n        case 26: {\n            if (remainingDataLength > 3) {\n                output = view.getUint32(0, false);\n                bytes = 5;\n            }\n            break;\n        }\n        case 27: {\n            if (remainingDataLength > 7) {\n                const bigOutput = view.getBigUint64(0, false);\n                // Bound it to [24, MAX_SAFE_INTEGER], where it is safe\n                // to encode as a javascript number\n                if (bigOutput >= 24n && bigOutput <= Number.MAX_SAFE_INTEGER) {\n                    return [Number(bigOutput), 9];\n                }\n                else {\n                    return [bigOutput, 9];\n                }\n            }\n            break;\n        }\n    }\n    if (output && output >= 24) {\n        return [output, bytes];\n    }\n    throw new Error(\"Length not supported or not well formed\");\n}\nexport const MAJOR_TYPE_UNSIGNED_INTEGER = 0;\nexport const MAJOR_TYPE_NEGATIVE_INTEGER = 1;\nexport const MAJOR_TYPE_BYTE_STRING = 2;\nexport const MAJOR_TYPE_TEXT_STRING = 3;\nexport const MAJOR_TYPE_ARRAY = 4;\nexport const MAJOR_TYPE_MAP = 5;\nexport const MAJOR_TYPE_TAG = 6;\nexport const MAJOR_TYPE_SIMPLE_OR_FLOAT = 7;\nexport function encodeLength(major, argument) {\n    const majorEncoded = major << 5;\n    if (argument < 0) {\n        throw new Error(\"CBOR Data Item argument must not be negative\");\n    }\n    // Convert to bigint first.\n    // Encode integers around and above 32 bits in big endian / network byte order\n    // is unreliable in javascript.\n    // https://tc39.es/ecma262/#sec-bitwise-shift-operators\n    // Bit shifting operations result in 32 bit signed numbers\n    let bigintArgument;\n    if (typeof argument == \"number\") {\n        if (!Number.isInteger(argument)) {\n            throw new Error(\"CBOR Data Item argument must be an integer\");\n        }\n        bigintArgument = BigInt(argument);\n    }\n    else {\n        bigintArgument = argument;\n    }\n    // Negative 0 is not a thing\n    if (major == MAJOR_TYPE_NEGATIVE_INTEGER) {\n        if (bigintArgument == 0n) {\n            throw new Error(\"CBOR Data Item argument cannot be zero when negative\");\n        }\n        bigintArgument = bigintArgument - 1n;\n    }\n    if (bigintArgument > 18446744073709551615n) {\n        throw new Error(\"CBOR number out of range\");\n    }\n    // Encode into 64 bits and extract the tail\n    const buffer = new Uint8Array(8);\n    const view = new DataView(buffer.buffer);\n    view.setBigUint64(0, bigintArgument, false);\n    if (bigintArgument <= 23) {\n        return [majorEncoded | buffer[7]];\n    }\n    else if (bigintArgument <= 255) {\n        return [majorEncoded | 24, buffer[7]];\n    }\n    else if (bigintArgument <= 65535) {\n        return [majorEncoded | 25, ...buffer.slice(6)];\n    }\n    else if (bigintArgument <= 4294967295) {\n        return [\n            majorEncoded | 26,\n            ...buffer.slice(4),\n        ];\n    }\n    else {\n        return [\n            majorEncoded | 27,\n            ...buffer,\n        ];\n    }\n}\n","import { decodeLength, encodeLength, MAJOR_TYPE_ARRAY, MAJOR_TYPE_BYTE_STRING, MAJOR_TYPE_MAP, MAJOR_TYPE_NEGATIVE_INTEGER, MAJOR_TYPE_SIMPLE_OR_FLOAT, MAJOR_TYPE_TAG, MAJOR_TYPE_TEXT_STRING, MAJOR_TYPE_UNSIGNED_INTEGER, } from \"./cbor_internal.js\";\n/**\n * A value which is wrapped with a CBOR Tag.\n * Several tags are registered with defined meanings like 0 for a date string.\n * These meanings are **not interpreted** when decoded or encoded.\n *\n * This class is an immutable record.\n * If the tag number or value needs to change, then construct a new tag\n */\nexport class CBORTag {\n    /**\n     * Wrap a value with a tag number.\n     * When encoded, this tag will be attached to the value.\n     *\n     * @param tag Tag number\n     * @param value Wrapped value\n     */\n    constructor(tag, value) {\n        Object.defineProperty(this, \"tagId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"tagValue\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.tagId = tag;\n        this.tagValue = value;\n    }\n    /**\n     * Read the tag number\n     */\n    get tag() {\n        return this.tagId;\n    }\n    /**\n     * Read the value\n     */\n    get value() {\n        return this.tagValue;\n    }\n}\nfunction decodeUnsignedInteger(data, argument, index) {\n    return decodeLength(data, argument, index);\n}\nfunction decodeNegativeInteger(data, argument, index) {\n    const [value, length] = decodeUnsignedInteger(data, argument, index);\n    if (typeof value === \"bigint\") {\n        return [-value - 1n, length];\n    }\n    return [-value - 1, length];\n}\nfunction decodeByteString(data, argument, index) {\n    const [lengthValue, lengthConsumed] = decodeLength(data, argument, index);\n    if (typeof lengthValue === \"bigint\") {\n        throw new Error(\"ByteString length is too large\");\n    }\n    const dataStartIndex = index + lengthConsumed;\n    return [\n        new Uint8Array(data.buffer.slice(dataStartIndex, dataStartIndex + lengthValue)),\n        lengthConsumed + lengthValue,\n    ];\n}\nconst TEXT_DECODER = new TextDecoder();\nfunction decodeString(data, argument, index) {\n    const [value, length] = decodeByteString(data, argument, index);\n    return [TEXT_DECODER.decode(value), length];\n}\nfunction decodeArray(data, argument, index) {\n    if (argument === 0) {\n        return [[], 1];\n    }\n    const [length, lengthConsumed] = decodeLength(data, argument, index);\n    let consumedLength = lengthConsumed;\n    const value = [];\n    for (let i = 0; i < length; i++) {\n        const remainingDataLength = data.byteLength - index - consumedLength;\n        if (remainingDataLength <= 0) {\n            throw new Error(\"array is not supported or well formed\");\n        }\n        const [decodedValue, consumed] = decodeNext(data, index + consumedLength);\n        value.push(decodedValue);\n        consumedLength += consumed;\n    }\n    return [value, consumedLength];\n}\nconst MAP_ERROR = \"Map is not supported or well formed\";\nfunction decodeMap(data, argument, index) {\n    if (argument === 0) {\n        return [new Map(), 1];\n    }\n    const [length, lengthConsumed] = decodeLength(data, argument, index);\n    let consumedLength = lengthConsumed;\n    const result = new Map();\n    for (let i = 0; i < length; i++) {\n        let remainingDataLength = data.byteLength - index - consumedLength;\n        if (remainingDataLength <= 0) {\n            throw new Error(MAP_ERROR);\n        }\n        // Load key\n        const [key, keyConsumed] = decodeNext(data, index + consumedLength);\n        consumedLength += keyConsumed;\n        remainingDataLength -= keyConsumed;\n        // Check that there's enough to have a value\n        if (remainingDataLength <= 0) {\n            throw new Error(MAP_ERROR);\n        }\n        // Technically CBOR maps can have any type as the key, and so can JS Maps\n        // However, JS Maps can only reference such keys as references which would\n        // require key iteration and pattern matching.\n        // For simplicity, since such keys are not in use with WebAuthn, this\n        // capability is not implemented and the types are restricted to strings\n        // and numbers.\n        if (typeof key !== \"string\" && typeof key !== \"number\") {\n            throw new Error(MAP_ERROR);\n        }\n        // CBOR Maps are not well formed if there are duplicate keys\n        if (result.has(key)) {\n            throw new Error(MAP_ERROR);\n        }\n        // Load value\n        const [value, valueConsumed] = decodeNext(data, index + consumedLength);\n        consumedLength += valueConsumed;\n        result.set(key, value);\n    }\n    return [result, consumedLength];\n}\nfunction decodeFloat16(data, index) {\n    if (index + 3 > data.byteLength) {\n        throw new Error(\"CBOR stream ended before end of Float 16\");\n    }\n    // Skip the first byte\n    const result = data.getUint16(index + 1, false);\n    // A minimal selection of supported values\n    if (result == 0x7c00) {\n        return [Infinity, 3];\n    }\n    else if (result == 0x7e00) {\n        return [NaN, 3];\n    }\n    else if (result == 0xfc00) {\n        return [-Infinity, 3];\n    }\n    throw new Error(\"Float16 data is unsupported\");\n}\nfunction decodeFloat32(data, index) {\n    if (index + 5 > data.byteLength) {\n        throw new Error(\"CBOR stream ended before end of Float 32\");\n    }\n    // Skip the first byte\n    const result = data.getFloat32(index + 1, false);\n    // First byte + 4 byte float\n    return [result, 5];\n}\nfunction decodeFloat64(data, index) {\n    if (index + 9 > data.byteLength) {\n        throw new Error(\"CBOR stream ended before end of Float 64\");\n    }\n    // Skip the first byte\n    const result = data.getFloat64(index + 1, false);\n    // First byte + 8 byte float\n    return [result, 9];\n}\nfunction decodeTag(data, argument, index) {\n    const [tag, tagBytes] = decodeLength(data, argument, index);\n    const [value, valueBytes] = decodeNext(data, index + tagBytes);\n    return [new CBORTag(tag, value), tagBytes + valueBytes];\n}\nfunction decodeNext(data, index) {\n    if (index >= data.byteLength) {\n        throw new Error(\"CBOR stream ended before tag value\");\n    }\n    const byte = data.getUint8(index);\n    const majorType = byte >> 5;\n    const argument = byte & 0x1f;\n    switch (majorType) {\n        case MAJOR_TYPE_UNSIGNED_INTEGER: {\n            return decodeUnsignedInteger(data, argument, index);\n        }\n        case MAJOR_TYPE_NEGATIVE_INTEGER: {\n            return decodeNegativeInteger(data, argument, index);\n        }\n        case MAJOR_TYPE_BYTE_STRING: {\n            return decodeByteString(data, argument, index);\n        }\n        case MAJOR_TYPE_TEXT_STRING: {\n            return decodeString(data, argument, index);\n        }\n        case MAJOR_TYPE_ARRAY: {\n            return decodeArray(data, argument, index);\n        }\n        case MAJOR_TYPE_MAP: {\n            return decodeMap(data, argument, index);\n        }\n        case MAJOR_TYPE_TAG: {\n            return decodeTag(data, argument, index);\n        }\n        case MAJOR_TYPE_SIMPLE_OR_FLOAT: {\n            switch (argument) {\n                case 20:\n                    return [false, 1];\n                case 21:\n                    return [true, 1];\n                case 22:\n                    return [null, 1];\n                case 23:\n                    return [undefined, 1];\n                // 24: Simple value (value 32..255 in following byte)\n                case 25: // IEEE 754 Half-Precision Float (16 bits follow)\n                    return decodeFloat16(data, index);\n                case 26: // IEEE 754 Single-Precision Float (32 bits follow)\n                    return decodeFloat32(data, index);\n                case 27: // IEEE 754 Double-Precision Float (64 bits follow)\n                    return decodeFloat64(data, index);\n                // 28-30: Reserved, not well-formed in the present document\n                // 31: \"break\" stop code for indefinite-length items\n            }\n        }\n    }\n    throw new Error(`Unsupported or not well formed at ${index}`);\n}\nfunction encodeSimple(data) {\n    if (data === true) {\n        return 0xf5;\n    }\n    else if (data === false) {\n        return 0xf4;\n    }\n    else if (data === null) {\n        return 0xf6;\n    }\n    // Else undefined\n    return 0xf7;\n}\nfunction encodeFloat(data) {\n    if (Math.fround(data) == data || !Number.isFinite(data) || Number.isNaN(data)) {\n        // Float32\n        const output = new Uint8Array(5);\n        output[0] = 0xfa;\n        const view = new DataView(output.buffer);\n        view.setFloat32(1, data, false);\n        return output;\n    }\n    else {\n        // Float64\n        const output = new Uint8Array(9);\n        output[0] = 0xfb;\n        const view = new DataView(output.buffer);\n        view.setFloat64(1, data, false);\n        return output;\n    }\n}\nfunction encodeNumber(data) {\n    if (typeof data == \"number\") {\n        if (Number.isSafeInteger(data)) {\n            // Encode integer\n            if (data < 0) {\n                return encodeLength(MAJOR_TYPE_NEGATIVE_INTEGER, Math.abs(data));\n            }\n            else {\n                return encodeLength(MAJOR_TYPE_UNSIGNED_INTEGER, data);\n            }\n        }\n        return [encodeFloat(data)];\n    }\n    else {\n        if (data < 0n) {\n            return encodeLength(MAJOR_TYPE_NEGATIVE_INTEGER, data * -1n);\n        }\n        else {\n            return encodeLength(MAJOR_TYPE_UNSIGNED_INTEGER, data);\n        }\n    }\n}\nconst ENCODER = new TextEncoder();\nfunction encodeString(data, output) {\n    output.push(...encodeLength(MAJOR_TYPE_TEXT_STRING, data.length));\n    output.push(ENCODER.encode(data));\n}\nfunction encodeBytes(data, output) {\n    output.push(...encodeLength(MAJOR_TYPE_BYTE_STRING, data.length));\n    output.push(data);\n}\nfunction encodeArray(data, output) {\n    output.push(...encodeLength(MAJOR_TYPE_ARRAY, data.length));\n    for (const element of data) {\n        encodePartialCBOR(element, output);\n    }\n}\nfunction encodeMap(data, output) {\n    output.push(new Uint8Array(encodeLength(MAJOR_TYPE_MAP, data.size)));\n    for (const [key, value] of data.entries()) {\n        encodePartialCBOR(key, output);\n        encodePartialCBOR(value, output);\n    }\n}\nfunction encodeTag(tag, output) {\n    output.push(...encodeLength(MAJOR_TYPE_TAG, tag.tag));\n    encodePartialCBOR(tag.value, output);\n}\nfunction encodePartialCBOR(data, output) {\n    if (typeof data == \"boolean\" || data === null || data == undefined) {\n        output.push(encodeSimple(data));\n        return;\n    }\n    if (typeof data == \"number\" || typeof data == \"bigint\") {\n        output.push(...encodeNumber(data));\n        return;\n    }\n    if (typeof data == \"string\") {\n        encodeString(data, output);\n        return;\n    }\n    if (data instanceof Uint8Array) {\n        encodeBytes(data, output);\n        return;\n    }\n    if (Array.isArray(data)) {\n        encodeArray(data, output);\n        return;\n    }\n    if (data instanceof Map) {\n        encodeMap(data, output);\n        return;\n    }\n    if (data instanceof CBORTag) {\n        encodeTag(data, output);\n        return;\n    }\n    throw new Error(\"Not implemented\");\n}\n/**\n * Like {decodeCBOR}, but the length of the data is unknown and there is likely\n * more -- possibly unrelated non-CBOR -- data afterwards.\n *\n * Examples:\n *\n * ```ts\n * import {decodePartialCBOR} from './cbor.ts'\n * decodePartialCBOR(new Uint8Array([1, 2, 245, 3, 4]), 2)\n * // returns [true, 1]\n * // It did not decode the leading [1, 2] or trailing [3, 4]\n * ```\n *\n * @param data a data stream to read data from\n * @param index where to start reading in the data stream\n * @returns a tuple of the value followed by bytes read.\n * @throws {Error}\n *   When the data stream ends early or the CBOR data is not well formed\n */\nexport function decodePartialCBOR(data, index) {\n    if (data.byteLength === 0 || data.byteLength <= index || index < 0) {\n        throw new Error(\"No data\");\n    }\n    const prototype = Object.getPrototypeOf(data);\n    const isArrayBuffer = prototype === ArrayBuffer.prototype;\n    // SharedArrayBuffer only exists when the page is viewed from a secure context.\n    const isSharedArrayBuffer = typeof SharedArrayBuffer !== \"undefined\" &&\n        prototype === SharedArrayBuffer.prototype;\n    if (prototype.constructor === Uint8Array.prototype.constructor) {\n        return decodeNext(new DataView(data.buffer), index);\n    }\n    else if (isArrayBuffer || isSharedArrayBuffer) {\n        return decodeNext(new DataView(data), index);\n    }\n    else if (prototype === DataView.prototype) {\n        return decodeNext(data, index);\n    }\n    else {\n        throw new Error(\"Unsupported data type\");\n    }\n}\n/**\n * Decode CBOR data from a binary stream\n *\n * The entire data stream from [0, length) will be consumed.\n * If you require a partial decoding, see {decodePartialCBOR}.\n *\n * Examples:\n *\n * ```ts\n * import {decodeCBOR, CBORTag, CBORType} from './cbor.ts'\n * decodeCBOR(new Uint8Array([162, 99, 107, 101, 121, 101, 118, 97, 108, 117, 101, 1, 109, 97, 110, 111, 116, 104, 101, 114, 32, 118, 97, 108, 117, 101]));\n * // returns new Map<string | number, CBORType>([\n * //   [\"key\", \"value\"],\n * //   [1, \"another value\"]\n * // ]);\n *\n * const taggedItem = new Uint8Array([217, 4, 210, 101, 104, 101, 108, 108, 111]);\n * decodeCBOR(new DataView(taggedItem.buffer))\n * // returns new CBORTag(1234, \"hello\")\n * ```\n *\n * @param data a data stream, multiple types are supported\n * @returns\n */\nexport function decodeCBOR(data) {\n    const [value, length] = decodePartialCBOR(data, 0);\n    if (length !== data.byteLength) {\n        throw new Error(`Data was decoded, but the whole stream was not processed ${length} != ${data.byteLength}`);\n    }\n    return value;\n}\n/**\n * Encode a supported structure to a CBOR byte string.\n *\n * Example:\n *\n * ```ts\n * import {encodeCBOR, CBORType, CBORTag} from './cbor.ts'\n * encodeCBOR(new Map<string | number, CBORType>([\n *   [\"key\", \"value\"],\n *   [1, \"another value\"]\n * ]));\n * // returns new Uint8Array([162, 99, 107, 101, 121, 101, 118, 97, 108, 117, 101, 1, 109, 97, 110, 111, 116, 104, 101, 114, 32 118, 97, 108, 117, 101])\n *\n * encodeCBOR(new CBORTag(1234, \"hello\"))\n * // returns new UInt8Array([217, 4, 210, 101, 104, 101, 108, 108, 111])\n * ```\n *\n * @param data Data to encode\n * @returns A byte string as a Uint8Array\n * @throws Error\n *   if unsupported data is found during encoding\n */\nexport function encodeCBOR(data) {\n    const results = [];\n    encodePartialCBOR(data, results);\n    let length = 0;\n    for (const result of results) {\n        if (typeof result == \"number\") {\n            length += 1;\n        }\n        else {\n            length += result.length;\n        }\n    }\n    const output = new Uint8Array(length);\n    let index = 0;\n    for (const result of results) {\n        if (typeof result == \"number\") {\n            output[index] = result;\n            index += 1;\n        }\n        else {\n            output.set(result, index);\n            index += result.length;\n        }\n    }\n    return output;\n}\n"]}