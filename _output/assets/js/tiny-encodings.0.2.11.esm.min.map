{"version":3,"sources":["jsdelivr-header.js","/npm/@levischuck/tiny-encodings@0.2.11/esm/internal.js","/npm/@levischuck/tiny-encodings@0.2.11/esm/encoding.js","/npm/@levischuck/tiny-encodings@0.2.11/esm/endianness_internal.js","/npm/@levischuck/tiny-encodings@0.2.11/esm/endianness.js"],"names":[],"mappings":"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","file":"/npm/@levischuck/tiny-encodings@0.2.11/esm/index.js/+esm","sourceRoot":"","sourcesContent":["/**\n * Bundled by jsDelivr using Rollup v2.79.2 and Terser v5.39.0.\n * Original file: /npm/@levischuck/tiny-encodings@0.2.11/esm/index.js\n *\n * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files\n */\n","export function bufferToDataView(v) {\n    if (v instanceof DataView) {\n        return v;\n    }\n    else if (v instanceof Uint8Array ||\n        v instanceof Int8Array ||\n        v instanceof Int16Array ||\n        v instanceof Uint16Array ||\n        v instanceof Int32Array ||\n        v instanceof Uint32Array ||\n        v instanceof Uint8ClampedArray ||\n        v instanceof Float32Array ||\n        v instanceof Float64Array ||\n        v instanceof BigInt64Array ||\n        v instanceof BigUint64Array) {\n        return new DataView(v.buffer);\n    }\n    else if (v instanceof ArrayBuffer) {\n        return new DataView(v);\n    }\n    throw new Error(\"Unsupported type\");\n}\n","import { bufferToDataView } from \"./internal.js\";\nconst DECODER = new TextDecoder();\nconst ENCODER = new TextEncoder();\nconst HEX = ENCODER.encode(\"0123456789ABCDEF\");\nconst HEX_CACHE = new Uint8Array(256);\nfunction encodeHexFromView(view) {\n    if (view.byteLength == 0) {\n        return \"\";\n    }\n    const length = view.byteLength;\n    const hexBytes = new Uint8Array(view.byteLength * 2);\n    for (let index = 0, outIndex = 0; index < length; index++, outIndex += 2) {\n        const byte = view.getUint8(index);\n        hexBytes[outIndex] = HEX[(byte & 0xF0) >> 4];\n        hexBytes[outIndex + 1] = HEX[byte & 0x0F];\n    }\n    return DECODER.decode(hexBytes);\n}\n/**\n * Encode a data view, typed array, or array buffer as a hex string\n *\n * Note that multi-byte types will be encoded according to the process's\n * endianness. Therefore, for portability, it is recommended to use\n * `arrayToEndian` on multi-byte typed arrays, such as Uint32Array before\n * encoding as hex.\n *\n * @param array input array to encode\n * @returns a string which when decoded as hex will have the same bytes as was\n *          input.\n */\nexport function encodeHex(array) {\n    if (array instanceof Uint8Array ||\n        array instanceof Int8Array ||\n        array instanceof Int16Array ||\n        array instanceof Uint16Array ||\n        array instanceof Int32Array ||\n        array instanceof Uint32Array ||\n        array instanceof Uint8ClampedArray ||\n        array instanceof Float32Array ||\n        array instanceof Float64Array ||\n        array instanceof BigInt64Array ||\n        array instanceof BigUint64Array) {\n        return encodeHexFromView(new DataView(array.buffer));\n    }\n    else if (array instanceof ArrayBuffer) {\n        return encodeHexFromView(new DataView(array));\n    }\n    else if (array instanceof DataView) {\n        return encodeHexFromView(array);\n    }\n    else {\n        throw new Error(\"Bad input to encodeHex\");\n    }\n}\nconst BAD_INPUT_HEX = \"Bad input to decodeHex\";\n/**\n * Decode a hex string into a Uint8Array\n *\n * Will throw when the input text has non hex characters, including spaces,\n * or when the input text has a length which is not even.\n *\n * Upper and lower A-F are accepted.\n * Characters outside of 0-9, A-F, a-f will throw.\n *\n * @param text input text of hex characters\n * @returns a decoded Uint8Array\n */\nexport function decodeHex(text) {\n    if (text == \"\") {\n        return new Uint8Array();\n    }\n    const hexBytes = ENCODER.encode(text);\n    let index = 0;\n    let badHex = false;\n    if (hexBytes.length & 1) {\n        // Only even lengths\n        throw new Error(BAD_INPUT_HEX);\n    }\n    if (HEX_CACHE[0] == 0) {\n        for (let i = 0; i < 256; i++) {\n            if (i >= 48 && i <= 57) {\n                HEX_CACHE[i] = i - 48;\n            }\n            else if (i >= 65 && i <= 70) {\n                HEX_CACHE[i] = i - 55;\n            }\n            else if (i >= 97 && i <= 102) {\n                HEX_CACHE[i] = i - 87;\n            }\n            else {\n                HEX_CACHE[i] = 255;\n            }\n        }\n    }\n    const bytes = new Uint8Array(Math.ceil(text.length / 2));\n    for (let i = 0; i < hexBytes.length; i += 2, index++) {\n        const leftHex = hexBytes[i];\n        const rightHex = hexBytes[i + 1];\n        const left = HEX_CACHE[leftHex];\n        const right = HEX_CACHE[rightHex];\n        bytes[index] = left << 4 | right;\n        if (left == 255 || right == 255) {\n            badHex = true;\n            break;\n        }\n    }\n    if (badHex) {\n        throw new Error(BAD_INPUT_HEX);\n    }\n    return bytes;\n}\nfunction encodeBase64Length(bufferLength, padding) {\n    const chunks = Math.ceil(bufferLength / 3);\n    const withPadding = chunks * 4;\n    const mod3 = bufferLength % 3;\n    const completeChunks = mod3 == 0 ? bufferLength : (bufferLength - mod3);\n    if (padding || mod3 == 0) {\n        return [withPadding, completeChunks, mod3];\n    }\n    if (mod3 == 1) {\n        return [withPadding - 2, completeChunks, mod3];\n    }\n    // mod3 == 2\n    return [withPadding - 1, completeChunks, mod3];\n}\nconst BASE64_ALPHABET = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\nconst BASE64_OUT = ENCODER.encode(BASE64_ALPHABET);\nconst BASE64_CACHE = new Uint8Array(256);\nconst BASE64_URL_ALPHABET = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\";\nconst BASE64_URL_OUT = ENCODER.encode(BASE64_URL_ALPHABET);\nconst BASE64_URL_CACHE = new Uint8Array(256);\nfunction encodeBase64Alphabet(array, out, padding) {\n    const view = bufferToDataView(array);\n    const [encodedLength, encodedChunkableLength, mod3] = encodeBase64Length(view.byteLength, padding);\n    const output = new Uint8Array(encodedLength);\n    let outputIndex = 0;\n    for (let i = 0; i < encodedChunkableLength; i += 3) {\n        const a = view.getUint8(i);\n        const b = view.getUint8(i + 1);\n        const c = view.getUint8(i + 2);\n        output[outputIndex] = out[(a & 0b1111_1100) >> 2];\n        output[outputIndex + 1] = out[(a & 0b11) << 4 | (b & 0b1111_0000) >> 4];\n        output[outputIndex + 2] = out[(b & 0b1111) << 2 | (c & 0b1100_0000) >> 6];\n        output[outputIndex + 3] = out[c & 0b0011_1111];\n        outputIndex += 4;\n    }\n    if (mod3 == 1) {\n        const a = view.getUint8(encodedChunkableLength);\n        output[outputIndex] = out[(a & 0b1111_1100) >> 2];\n        output[outputIndex + 1] = out[(a & 0b0000_0011) << 4];\n        if (padding) {\n            output[outputIndex + 2] = 61;\n            output[outputIndex + 3] = 61;\n        }\n    }\n    else if (mod3 == 2) {\n        const a = view.getUint8(encodedChunkableLength);\n        const b = view.getUint8(encodedChunkableLength + 1);\n        output[outputIndex] = out[(a & 0b1111_1100) >> 2];\n        output[outputIndex + 1] =\n            out[(a & 0b0000_0011) << 4 | (b & 0b1111_0000) >> 4];\n        output[outputIndex + 2] = out[(b & 0b1111) << 2];\n        if (padding) {\n            output[outputIndex + 3] = 61;\n        }\n    }\n    return DECODER.decode(output);\n}\n/**\n * A base64 standard implementation, see RFC4648\n * https://datatracker.ietf.org/doc/html/rfc4648\n * section Base 64 Encoding\n *\n * This function will encode input bytes into a string using the characters\n * A-Z, a-z, 0-9, +, /, and = as padding at the end.\n *\n * Note that multi-byte types will be encoded according to the process's\n * endianness. Therefore, for portability, it is recommended to use\n * `arrayToEndian` on multi-byte typed arrays, such as Uint32Array before\n * encoding as hex.\n *\n * @param array Input data to encode\n * @returns a text string matching Base64\n */\nexport function encodeBase64(array) {\n    return encodeBase64Alphabet(array, BASE64_OUT, true);\n}\n/**\n * A base64 url implementation, see RFC4648\n * https://datatracker.ietf.org/doc/html/rfc4648 section\n * Base 64 Encoding with URL and Filename Safe Alphabet\n *\n * This function will encode input bytes into a string using the characters\n * A-Z, a-z, 0-9, -, _, and with no padding.\n *\n * Note that multi-byte types will be encoded according to the process's\n * endianness. Therefore, for portability, it is recommended to use\n * `arrayToEndian` on multi-byte typed arrays, such as Uint32Array before\n * encoding as hex.\n *\n * @param array Input data to encode\n * @returns a text string matching Base64\n */\nexport function encodeBase64Url(array) {\n    return encodeBase64Alphabet(array, BASE64_URL_OUT, false);\n}\nfunction decodeBase64Alphabet(input, length, lengthMod4, output, alphabet) {\n    let index = 0;\n    let unsupported = null;\n    const totalLength = length - lengthMod4;\n    for (let i = 0; i < totalLength; i += 4, index += 3) {\n        const aValue = alphabet[input[i]];\n        const bValue = alphabet[input[i + 1]];\n        const cValue = alphabet[input[i + 2]];\n        const dValue = alphabet[input[i + 3]];\n        output[index] = (aValue << 2) | ((bValue & 0b110000) >> 4);\n        output[index + 1] = ((bValue & 0xF) << 4) | ((cValue & 0b111100) >> 2);\n        output[index + 2] = ((cValue & 0b11) << 6) | dValue;\n        if (aValue == 255 || bValue == 255 || cValue == 255 || dValue == 255) {\n            unsupported = i;\n            break;\n        }\n    }\n    if (unsupported != null) {\n        throw new Error(\"Unsupported characters in base64: \" + DECODER.decode(new Uint8Array([\n            input[unsupported],\n            input[unsupported + 1],\n            input[unsupported + 2],\n            input[unsupported + 3],\n        ])));\n    }\n    if (lengthMod4 == 2) {\n        const a = input[length - 2];\n        const b = input[length - 1];\n        const aValue = alphabet[a];\n        const bValue = alphabet[b];\n        if ((aValue | bValue) == 255) {\n            throw new Error(\"Unsupported characters in base64: \" +\n                DECODER.decode(new Uint8Array([a, b])) +\n                JSON.stringify([aValue, bValue]));\n        }\n        output[index] = (aValue << 2) | ((bValue & 0b110000) >> 4);\n        if ((bValue & 0b1111) != 0) {\n            throw new Error(\"Mangled Base64 padding\");\n        }\n    }\n    else if (lengthMod4 == 3) {\n        const a = input[length - 3];\n        const b = input[length - 2];\n        const c = input[length - 1];\n        const aValue = alphabet[a];\n        const bValue = alphabet[b];\n        const cValue = alphabet[c];\n        if ((aValue | bValue | cValue) == 255) {\n            throw new Error(\"Unsupported characters in base64: \" +\n                DECODER.decode(new Uint8Array([a, b, c])) +\n                JSON.stringify([aValue, bValue, cValue]));\n        }\n        output[index] = (aValue << 2) | ((bValue & 0b110000) >> 4);\n        output[index + 1] = ((bValue & 0xF) << 4) | ((cValue & 0b111100) >> 2);\n        if ((cValue & 0b11) != 0) {\n            throw new Error(\"Mangled Base64 padding\");\n        }\n    }\n}\nfunction calculateLength(text) {\n    let length = text.length;\n    // Subtract padding\n    for (let i = length - 1; i >= 0; i--) {\n        if (text[i] == 61) {\n            length = i;\n        }\n    }\n    const lengthMod4 = length % 4;\n    let byteLength;\n    if (lengthMod4 == 2) {\n        byteLength = ((length - 2) / 4) * 3 + 1;\n    }\n    else if (lengthMod4 == 3) {\n        byteLength = ((length - 3) / 4) * 3 + 2;\n    }\n    else if (lengthMod4 == 0) {\n        byteLength = length / 4 * 3;\n    }\n    else {\n        throw new Error(\"Invalid base64 length\");\n    }\n    return [length, lengthMod4, byteLength];\n}\n/**\n * Decode a base64 standard input into a Uint8Array\n *\n * This function will throw when characters other than A-Z, a-z, 0-9, +, and\n * / are used, with the exception of allowing = at the end.\n *\n * This function will throw when the base64 input padding is mangled.\n *\n * This function will throw when the length does not meet expectations.\n *\n * @param text Input base64 standard string\n * @returns an output Uint8Array of decoded bytes\n */\nexport function decodeBase64(text) {\n    if (typeof text != \"string\") {\n        throw new Error(\"Expecting a string\");\n    }\n    if (text.length == 0) {\n        return new Uint8Array([]);\n    }\n    if (BASE64_CACHE[0] == 0) {\n        for (let i = 0; i < 256; i++) {\n            BASE64_CACHE[i] = 255;\n        }\n        for (let i = 0; i < BASE64_ALPHABET.length; i++) {\n            BASE64_CACHE[BASE64_ALPHABET.charCodeAt(i)] = i;\n        }\n    }\n    const input = ENCODER.encode(text);\n    const [length, lengthMod4, byteLength] = calculateLength(input);\n    const output = new Uint8Array(byteLength);\n    decodeBase64Alphabet(input, length, lengthMod4, output, BASE64_CACHE);\n    return output;\n}\n/**\n * Decode a base64 url input into a Uint8Array\n *\n * This function will throw when characters other than A-Z, a-z, 0-9, -, and\n * _ are used. No padding is expected.\n *\n * This function will throw when the base64 input padding is mangled.\n *\n * This function will throw when the length does not meet expectations.\n *\n * @param text Input base64 standard string\n * @returns an output Uint8Array of decoded bytes\n */\nexport function decodeBase64Url(text) {\n    if (typeof text != \"string\") {\n        throw new Error(\"Expecting a string\");\n    }\n    if (text.length == 0) {\n        return new Uint8Array([]);\n    }\n    if (BASE64_URL_CACHE[0] == 0) {\n        for (let i = 0; i < 256; i++) {\n            BASE64_URL_CACHE[i] = 255;\n        }\n        for (let i = 0; i < BASE64_URL_ALPHABET.length; i++) {\n            BASE64_URL_CACHE[BASE64_URL_ALPHABET.charCodeAt(i)] = i;\n        }\n    }\n    const input = ENCODER.encode(text);\n    const [length, lengthMod4, byteLength] = calculateLength(input);\n    const output = new Uint8Array(byteLength);\n    decodeBase64Alphabet(input, length, lengthMod4, output, BASE64_URL_CACHE);\n    return output;\n}\n","export const ENDIAN_TEST = new Uint8Array(2);\nconst MULTI_BYTE_VIEW = new Uint16Array(ENDIAN_TEST.buffer);\nMULTI_BYTE_VIEW[0] = 1;\nexport function testOnlySetBigEndian() {\n    ENDIAN_TEST[0] = 0;\n    ENDIAN_TEST[1] = 1;\n}\nexport function testOnlySetLittleEndian() {\n    ENDIAN_TEST[0] = 1;\n    ENDIAN_TEST[1] = 0;\n}\n","import { ENDIAN_TEST } from \"./endianness_internal.js\";\nimport { bufferToDataView } from \"./internal.js\";\n/**\n * Inspect if the byte ordering of this process is big endian.\n *\n * @returns true if the process uses big endian memory order\n */\nexport function hostIsBigEndian() {\n    return ENDIAN_TEST[1] != 0;\n}\n/**\n * Inspect if the byte ordering of this process is little endian.\n *\n * @returns true if the process uses little endian memory order\n */\nexport function hostIsLittleEndian() {\n    return ENDIAN_TEST[0] != 0;\n}\n/**\n * Inspect if the byte ordering of this process is big or little endian.\n *\n * @returns \"big\" if the system is big endian, otherwise \"little\".\n */\nexport function hostEndianness() {\n    return hostIsBigEndian() ? \"big\" : \"little\";\n}\nfunction internalArrayTo(array, endianness, width, fun) {\n    const out = new Uint8Array(array.byteLength);\n    const view = new DataView(out.buffer);\n    const length = array.length;\n    const little = endianness == \"little\";\n    for (let i = 0, outIndex = 0; i < length; i++, outIndex += width) {\n        fun(view, outIndex, array[i], little);\n    }\n    return out;\n}\nfunction internalArrayFrom(view, littleEndian, width, output, fun) {\n    for (let i = 0, j = 0; i < view.byteLength; j++, i += width) {\n        output[j] = fun(view, i, littleEndian);\n    }\n    return output;\n}\n/**\n * This function takes a typed input array and encodes all elements in the\n * requested endianness order, so that the input array may be communicated\n * in a reliable way to another recipient.\n *\n * Protocols may specify that numbers are encoded in \"big\" endian, while the\n * host uses \"little\" endian byte ordering in memory. This function may help\n * in ensuring that sequences of multi-byte numbers are portable between\n * processes.\n *\n * @param array Input array to encode\n * @param endianness what endianness to encode the input array as\n * @returns an output Uint8Array with bytes set in the requested endianness\n *          order which represents the multi-byte numbers in the input array.\n */\nexport function arrayToEndian(array, endianness) {\n    if (array instanceof Uint8Array) {\n        return array;\n    }\n    else if (array instanceof Uint16Array) {\n        return internalArrayTo(array, endianness, 2, (v, i, n, l) => v.setUint16(i, n, l));\n    }\n    else if (array instanceof Int16Array) {\n        return internalArrayTo(array, endianness, 2, (v, i, n, l) => v.setInt16(i, n, l));\n    }\n    else if (array instanceof Uint32Array) {\n        return internalArrayTo(array, endianness, 4, (v, i, n, l) => v.setUint32(i, n, l));\n    }\n    else if (array instanceof Int32Array) {\n        return internalArrayTo(array, endianness, 4, (v, i, n, l) => v.setInt32(i, n, l));\n    }\n    else if (array instanceof BigUint64Array) {\n        return internalArrayTo(array, endianness, 8, (v, i, n, l) => v.setBigUint64(i, n, l));\n    }\n    else if (array instanceof BigInt64Array) {\n        return internalArrayTo(array, endianness, 8, (v, i, n, l) => v.setBigInt64(i, n, l));\n    }\n    else if (array instanceof Float32Array) {\n        return internalArrayTo(array, endianness, 4, (v, i, n, l) => v.setFloat32(i, n, l));\n    }\n    else if (array instanceof Float64Array) {\n        return internalArrayTo(array, endianness, 8, (v, i, n, l) => v.setFloat64(i, n, l));\n    }\n    // Int8Array\n    return new Uint8Array(array.buffer);\n}\n/**\n * This function receives a sequence of bytes, which is known to contain\n * multi-byte numbers encoded with a known endianness, and outputs a typed\n * array of those multi-byte numbers in the requested format / type.\n *\n * Will throw if the input array is not sized for the type that is asked for.\n * If you are processing a section of data in a larger sequence of bytes then\n * use a DataView.\n *\n * @param array Source bytes to read from, various types are supported, the\n *              bytes will be read as they are stored in memory. While it can\n *              take a Uint32Array type, this is not advised.\n * @param endianness the endianness of bytes, most protocols use \"big\",\n *                   while most systems use \"little\".\n * @param type the output type desired, for example \"uint32\" will\n *             return a Uint32Array.\n * @returns a typed array populated with the numbers sourced from the input\n *          array with the endianness taken into account\n */\nexport function arrayFromEndian(array, endianness, type) {\n    const view = bufferToDataView(array);\n    const littleEndian = endianness == \"little\";\n    if (type == \"int8\") {\n        return internalArrayFrom(view, littleEndian, 1, new Int8Array(view.byteLength), (v, i, _l) => v.getInt8(i));\n    }\n    else if (type == \"uint16\") {\n        if (view.byteLength & 1) {\n            throw new Error(\"Incomplete byte sequence\");\n        }\n        return internalArrayFrom(view, littleEndian, 2, new Uint16Array(view.byteLength >>> 1), (v, i, l) => v.getUint16(i, l));\n    }\n    else if (type == \"int16\") {\n        if (view.byteLength & 1) {\n            throw new Error(\"Incomplete byte sequence\");\n        }\n        return internalArrayFrom(view, littleEndian, 2, new Int16Array(view.byteLength >>> 1), (v, i, l) => v.getInt16(i, l));\n    }\n    else if (type == \"uint32\") {\n        if (view.byteLength & 3) {\n            throw new Error(\"Incomplete byte sequence\");\n        }\n        return internalArrayFrom(view, littleEndian, 4, new Uint32Array(view.byteLength >>> 2), (v, i, l) => v.getUint32(i, l));\n    }\n    else if (type == \"int32\") {\n        if (view.byteLength & 3) {\n            throw new Error(\"Incomplete byte sequence\");\n        }\n        return internalArrayFrom(view, littleEndian, 4, new Int32Array(view.byteLength >>> 2), (v, i, l) => v.getInt32(i, l));\n    }\n    else if (type == \"uint64\") {\n        if (view.byteLength & 7) {\n            throw new Error(\"Incomplete byte sequence\");\n        }\n        return internalArrayFrom(view, littleEndian, 8, new BigUint64Array(view.byteLength >>> 3), (v, i, l) => v.getBigUint64(i, l));\n    }\n    else if (type == \"int64\") {\n        if (view.byteLength & 7) {\n            throw new Error(\"Incomplete byte sequence\");\n        }\n        return internalArrayFrom(view, littleEndian, 8, new BigInt64Array(view.byteLength >>> 3), (v, i, l) => v.getBigInt64(i, l));\n    }\n    else if (type == \"float32\") {\n        if (view.byteLength & 3) {\n            throw new Error(\"Incomplete byte sequence\");\n        }\n        return internalArrayFrom(view, littleEndian, 4, new Float32Array(view.byteLength >>> 2), (v, i, l) => v.getFloat32(i, l));\n    }\n    else if (type == \"float64\") {\n        if (view.byteLength & 7) {\n            throw new Error(\"Incomplete byte sequence\");\n        }\n        return internalArrayFrom(view, littleEndian, 8, new Float64Array(view.byteLength >>> 3), (v, i, l) => v.getFloat64(i, l));\n    }\n    // Last is uint8\n    return new Uint8Array(view.buffer.slice(view.byteOffset, view.byteOffset + view.byteLength));\n}\n"]}